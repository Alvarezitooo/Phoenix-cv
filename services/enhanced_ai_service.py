"""
ðŸš€ Enhanced AI Service - Phoenix CV
Service IA enrichi alignÃ© avec Phoenix Letters
"""

import google.generativeai as genai
import streamlit as st
from typing import Dict, List, Optional, Any, Tuple
import json
import re
from datetime import datetime
import time
from models.cv_data import CVProfile, ATSAnalysis, CVTier
from utils.secure_validator import SecureValidator
from utils.secure_logging import SecureLogger

class EnhancedAIService:
    """Service IA enrichi pour Phoenix CV avec fonctionnalitÃ©s avancÃ©es"""
    
    def __init__(self):
        self.logger = SecureLogger()
        self.validator = SecureValidator()
        self._initialize_gemini()
        
        # Compteurs pour analytics
        self.generation_stats = {
            'total_requests': 0,
            'successful_generations': 0,
            'failed_generations': 0,
            'avg_response_time': 0
        }
    
    def _initialize_gemini(self):
        """Initialise Gemini avec configuration sÃ©curisÃ©e"""
        try:
            api_key = st.secrets.get("GEMINI_API_KEY")
            if not api_key:
                raise ValueError("GEMINI_API_KEY non configurÃ©e")
            
            genai.configure(api_key=api_key)
            self.model = genai.GenerativeModel('gemini-1.5-flash')
            
            # Configuration de sÃ©curitÃ©
            self.safety_settings = [
                {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
                {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
                {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
                {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"}
            ]
            
        except Exception as e:
            self.logger.log_error(f"Erreur initialisation Gemini: {e}")
            raise
    
    def enhance_professional_summary(self, cv_profile: CVProfile, target_position: str = "") -> str:
        """AmÃ©liore le rÃ©sumÃ© professionnel avec IA"""
        start_time = time.time()
        self.generation_stats['total_requests'] += 1
        
        try:
            # Construction du prompt sÃ©curisÃ©
            prompt = self._build_summary_prompt(cv_profile, target_position)
            
            # Validation anti-injection
            if not self.validator.validate_prompt_safety(prompt):
                raise ValueError("Prompt non sÃ©curisÃ© dÃ©tectÃ©")
            
            # GÃ©nÃ©ration avec retry
            response = self._generate_with_retry(prompt)
            
            # Post-traitement sÃ©curisÃ©
            enhanced_summary = self._clean_and_validate_response(response)
            
            # Mise Ã  jour stats
            response_time = time.time() - start_time
            self._update_stats(True, response_time)
            
            return enhanced_summary
            
        except Exception as e:
            self.logger.log_error(f"Erreur gÃ©nÃ©ration rÃ©sumÃ©: {e}")
            self._update_stats(False, time.time() - start_time)
            return cv_profile.professional_summary  # Fallback
    
    def optimize_for_ats(self, cv_profile: CVProfile, job_description: str) -> Tuple[CVProfile, ATSAnalysis]:
        """Optimise le CV pour les systÃ¨mes ATS"""
        start_time = time.time()
        
        try:
            # Analyse des mots-clÃ©s
            keywords_analysis = self._extract_job_keywords(job_description)
            
            # Optimisation du contenu
            optimized_profile = self._optimize_cv_content(cv_profile, keywords_analysis)
            
            # Analyse ATS finale
            ats_analysis = self._perform_ats_analysis(optimized_profile, job_description)
            
            self.logger.log_info(f"Optimisation ATS rÃ©ussie - Score: {ats_analysis.score}")
            
            return optimized_profile, ats_analysis
            
        except Exception as e:
            self.logger.log_error(f"Erreur optimisation ATS: {e}")
            # Retour du profil original avec analyse basique
            basic_analysis = ATSAnalysis(
                score=50,
                level="Moyen",
                recommendations=["Optimisation non disponible temporairement"]
            )
            return cv_profile, basic_analysis
    
    def generate_achievement_suggestions(self, experience_description: str, position: str) -> List[str]:
        """GÃ©nÃ¨re des suggestions de rÃ©alisations pour une expÃ©rience"""
        try:
            prompt = f"""
            En tant qu'expert en rÃ©daction CV, amÃ©liore cette description d'expÃ©rience pour le poste de {position}.
            
            Description actuelle:
            {experience_description}
            
            GÃ©nÃ¨re 3 rÃ©alisations spÃ©cifiques et quantifiÃ©es qui pourraient correspondre Ã  ce poste.
            Utilise des verbes d'action et des mÃ©triques concrÃ¨tes.
            
            Format: Liste numÃ©rotÃ©e simple, une rÃ©alisation par ligne.
            """
            
            response = self._generate_with_retry(prompt)
            achievements = self._parse_achievements_list(response)
            
            return achievements[:3]  # Maximum 3 suggestions
            
        except Exception as e:
            self.logger.log_error(f"Erreur gÃ©nÃ©ration rÃ©alisations: {e}")
            return ["OptimisÃ© les processus de l'Ã©quipe", "Atteint les objectifs fixÃ©s", "CollaborÃ© efficacement"]
    
    def analyze_skill_gaps(self, cv_profile: CVProfile, job_description: str) -> Dict[str, List[str]]:
        """Analyse les lacunes en compÃ©tences par rapport Ã  l'offre"""
        try:
            current_skills = [skill.name.lower() for skill in cv_profile.skills]
            
            # Extraction des compÃ©tences requises
            required_skills = self._extract_required_skills(job_description)
            
            # Identification des lacunes
            missing_skills = [skill for skill in required_skills if skill.lower() not in current_skills]
            matching_skills = [skill for skill in required_skills if skill.lower() in current_skills]
            
            return {
                'missing_skills': missing_skills,
                'matching_skills': matching_skills,
                'suggestions': self._generate_skill_suggestions(missing_skills)
            }
            
        except Exception as e:
            self.logger.log_error(f"Erreur analyse compÃ©tences: {e}")
            return {'missing_skills': [], 'matching_skills': [], 'suggestions': []}
    
    def get_generation_stats(self) -> Dict[str, Any]:
        """Retourne les statistiques de gÃ©nÃ©ration"""
        success_rate = 0
        if self.generation_stats['total_requests'] > 0:
            success_rate = (self.generation_stats['successful_generations'] / 
                          self.generation_stats['total_requests']) * 100
        
        return {
            'total_requests': self.generation_stats['total_requests'],
            'success_rate': round(success_rate, 2),
            'avg_response_time': round(self.generation_stats['avg_response_time'], 2),
            'last_updated': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
    
    # MÃ©thodes privÃ©es
    
    def _build_summary_prompt(self, cv_profile: CVProfile, target_position: str) -> str:
        """Construit un prompt sÃ©curisÃ© pour le rÃ©sumÃ© professionnel"""
        experiences_summary = ""
        for exp in cv_profile.experiences[:3]:  # Top 3 expÃ©riences
            experiences_summary += f"- {exp.position} chez {exp.company}\n"
        
        skills_summary = ", ".join([skill.name for skill in cv_profile.skills[:8]])
        
        prompt = f"""
        En tant qu'expert en rÃ©daction de CV pour reconversions professionnelles, 
        crÃ©ez un rÃ©sumÃ© professionnel percutant pour ce profil.
        
        Profil candidat:
        - ExpÃ©riences clÃ©s: {experiences_summary}
        - CompÃ©tences: {skills_summary}
        - Poste visÃ©: {target_position or "Ã‰volution de carriÃ¨re"}
        
        CrÃ©ez un rÃ©sumÃ© de 3-4 lignes qui:
        1. Met en valeur les compÃ©tences transfÃ©rables
        2. Montre la motivation pour la reconversion
        3. Utilise des mots-clÃ©s du domaine visÃ©
        4. Reste concis et impactant
        
        RÃ©ponse: paragraphe unique sans formatage.
        """
        
        return prompt
    
    def _generate_with_retry(self, prompt: str, max_retries: int = 3) -> str:
        """GÃ©nÃ¨re du contenu avec systÃ¨me de retry"""
        for attempt in range(max_retries):
            try:
                response = self.model.generate_content(
                    prompt,
                    safety_settings=self.safety_settings,
                    generation_config=genai.types.GenerationConfig(
                        max_output_tokens=1000,
                        temperature=0.7
                    )
                )
                
                if response.text:
                    return response.text.strip()
                else:
                    raise ValueError("RÃ©ponse vide du modÃ¨le")
                    
            except Exception as e:
                if attempt == max_retries - 1:
                    raise e
                time.sleep(2 ** attempt)  # Backoff exponentiel
    
    def _clean_and_validate_response(self, response: str) -> str:
        """Nettoie et valide la rÃ©ponse IA"""
        # Suppression des caractÃ¨res indÃ©sirables
        cleaned = re.sub(r'[^\w\s\-\.,;:()\[\]{}]', '', response)
        
        # Validation longueur
        if len(cleaned) > 2000:
            cleaned = cleaned[:2000] + "..."
        
        # Validation contenu offensant (basique)
        forbidden_words = ['hack', 'exploit', 'malicious', 'attack']
        for word in forbidden_words:
            if word.lower() in cleaned.lower():
                raise ValueError("Contenu potentiellement dangereux dÃ©tectÃ©")
        
        return cleaned
    
    def _extract_job_keywords(self, job_description: str) -> List[str]:
        """Extrait les mots-clÃ©s importants de l'offre d'emploi"""
        try:
            prompt = f"""
            Extrais les 15 mots-clÃ©s les plus importants de cette offre d'emploi.
            Concentre-toi sur les compÃ©tences techniques, outils, et qualifications.
            
            Offre d'emploi:
            {job_description[:1500]}
            
            Format: Liste sÃ©parÃ©e par des virgules, un mot-clÃ© par Ã©lÃ©ment.
            """
            
            response = self._generate_with_retry(prompt)
            keywords = [kw.strip() for kw in response.split(',') if kw.strip()]
            
            return keywords[:15]
            
        except Exception as e:
            self.logger.log_error(f"Erreur extraction mots-clÃ©s: {e}")
            return []
    
    def _optimize_cv_content(self, cv_profile: CVProfile, keywords: List[str]) -> CVProfile:
        """Optimise le contenu CV avec les mots-clÃ©s identifiÃ©s"""
        # Copie du profil pour modification
        optimized_profile = cv_profile
        
        # Optimisation du rÃ©sumÃ© professionnel
        if keywords and cv_profile.professional_summary:
            summary_with_keywords = self._integrate_keywords_in_summary(
                cv_profile.professional_summary, keywords[:5]
            )
            optimized_profile.professional_summary = summary_with_keywords
        
        return optimized_profile
    
    def _integrate_keywords_in_summary(self, summary: str, keywords: List[str]) -> str:
        """IntÃ¨gre naturellement des mots-clÃ©s dans le rÃ©sumÃ©"""
        try:
            prompt = f"""
            AmÃ©liore ce rÃ©sumÃ© professionnel en intÃ©grant naturellement ces mots-clÃ©s: {', '.join(keywords)}
            
            RÃ©sumÃ© actuel:
            {summary}
            
            Consignes:
            - Garde le sens et le style original
            - IntÃ¨gre 2-3 mots-clÃ©s maximum
            - Reste naturel et fluide
            - Maximum 4 lignes
            
            RÃ©sumÃ© optimisÃ©:
            """
            
            response = self._generate_with_retry(prompt)
            return self._clean_and_validate_response(response)
            
        except Exception as e:
            self.logger.log_error(f"Erreur intÃ©gration mots-clÃ©s: {e}")
            return summary  # Retour original si erreur
    
    def _perform_ats_analysis(self, cv_profile: CVProfile, job_description: str) -> ATSAnalysis:
        """Effectue une analyse ATS du CV"""
        score = 75  # Score de base
        recommendations = []
        missing_keywords = []
        
        # Analyse basique des sections
        sections_score = 0
        if cv_profile.professional_summary:
            sections_score += 20
        if cv_profile.experiences:
            sections_score += 25
        if cv_profile.skills:
            sections_score += 20
        if cv_profile.education:
            sections_score += 15
        
        final_score = min(100, sections_score + 20)  # Score bonus pour complÃ©tude
        
        # Recommandations basÃ©es sur le score
        if final_score < 60:
            recommendations.append("ComplÃ©tez toutes les sections principales du CV")
        if not cv_profile.professional_summary:
            recommendations.append("Ajoutez un rÃ©sumÃ© professionnel accrocheur")
        if len(cv_profile.skills) < 5:
            recommendations.append("Enrichissez la section compÃ©tences")
        
        return ATSAnalysis(
            score=final_score,
            level="",  # Sera dÃ©terminÃ© automatiquement
            missing_keywords=missing_keywords,
            recommendations=recommendations,
            keyword_density={},
            sections_analyzed=["summary", "experience", "skills", "education"]
        )
    
    def _parse_achievements_list(self, response: str) -> List[str]:
        """Parse la rÃ©ponse pour extraire une liste de rÃ©alisations"""
        lines = response.split('\n')
        achievements = []
        
        for line in lines:
            # Nettoie et filtre les lignes valides
            cleaned = line.strip()
            if cleaned and (cleaned[0].isdigit() or cleaned.startswith('-') or cleaned.startswith('â€¢')):
                # Supprime les numÃ©ros/puces du dÃ©but
                achievement = re.sub(r'^[\d\-â€¢.\s]+', '', cleaned).strip()
                if achievement and len(achievement) > 10:
                    achievements.append(achievement)
        
        return achievements[:5]  # Maximum 5 achievements
    
    def _extract_required_skills(self, job_description: str) -> List[str]:
        """Extrait les compÃ©tences requises de l'offre d'emploi"""
        # MÃ©thode simplifiÃ©e - dans un vrai projet, utiliser NLP plus avancÃ©
        common_skills = [
            'Python', 'JavaScript', 'React', 'Angular', 'Vue.js', 'Node.js',
            'Java', 'C++', 'SQL', 'PostgreSQL', 'MySQL', 'MongoDB',
            'AWS', 'Azure', 'Docker', 'Kubernetes', 'Git', 'Jenkins',
            'Agile', 'Scrum', 'Leadership', 'Management', 'Communication'
        ]
        
        found_skills = []
        job_lower = job_description.lower()
        
        for skill in common_skills:
            if skill.lower() in job_lower:
                found_skills.append(skill)
        
        return found_skills
    
    def _generate_skill_suggestions(self, missing_skills: List[str]) -> List[str]:
        """GÃ©nÃ¨re des suggestions pour acquÃ©rir les compÃ©tences manquantes"""
        suggestions = []
        
        for skill in missing_skills[:3]:  # Top 3 compÃ©tences manquantes
            suggestion = f"DÃ©veloppez vos compÃ©tences en {skill} via des formations en ligne"
            suggestions.append(suggestion)
        
        return suggestions
    
    def _update_stats(self, success: bool, response_time: float):
        """Met Ã  jour les statistiques de gÃ©nÃ©ration"""
        if success:
            self.generation_stats['successful_generations'] += 1
        else:
            self.generation_stats['failed_generations'] += 1
        
        # Calcul de la moyenne mobile du temps de rÃ©ponse
        current_avg = self.generation_stats['avg_response_time']
        total_requests = self.generation_stats['total_requests']
        
        self.generation_stats['avg_response_time'] = (
            (current_avg * (total_requests - 1) + response_time) / total_requests
        )